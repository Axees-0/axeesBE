// controllers/connectController.js
const jwt = require("jsonwebtoken");
const User = require("../models/User");
const stripe = require("stripe")(process.env.STRIPE_SECRET_KEY);
const FRONTEND_URL = process.env.FRONTEND_URL;
const { faker } = require('@faker-js/faker');

exports.onboardConnectAccount = async (req, res) => {
  try {
    
    const { userId } = req.body;

    const dbUser = await User.findById(userId).select('+stripeConnectId +email');    

    let stripeConnectId = dbUser.stripeConnectId;

    if (!stripeConnectId) {
      const account = await stripe.accounts.create({
        type: 'express',
        country: 'US',
        email: dbUser.email,
        capabilities: { transfers: { requested: true } },
        metadata: { userId: dbUser._id.toString() },
      });
      console.log('Created Stripe account:', account.id);
      console.log('Metadata set during creation:', account.metadata);

      // Update the account with fake details generated by Faker
      const updatedAccount = await stripe.accounts.update(account.id, {
        business_type: 'individual',
        business_profile: {
          url: faker.internet.url(), // Generate a random URL (e.g., "https://lorem.com")
          mcc: '5734', // Merchant Category Code (keeping as "Computer Software Stores" for consistency)
        },
        individual: {
          first_name: faker.person.firstName(), // Random first name (e.g., "John")
          last_name: faker.person.lastName(), // Random last name (e.g., "Doe")
          email: dbUser.email, // Use the user's email as specified
          phone: faker.phone.number('+1201######'), // Random US phone number (e.g., "+12015550123")
          dob: {
            day: faker.number.int({ min: 1, max: 28 }), // Random day (1-28 to avoid invalid dates)
            month: faker.number.int({ min: 1, max: 12 }), // Random month (1-12)
            year: faker.number.int({ min: 1970, max: 2000 }), // Random year (1970-2000)
          },
          address: {
            line1: faker.location.streetAddress(), // Random street address (e.g., "123 Main St")
            city: faker.location.city(), // Random city (e.g., "San Francisco")
            state: faker.location.state({ abbreviated: true }), // Random US state abbreviation (e.g., "CA")
            postal_code: faker.location.zipCode('#####'), // Random 5-digit ZIP code (e.g., "94105")
            country: 'US', // Keep as US
          },
          ssn_last_4: faker.string.numeric(4), // Random 4-digit number (e.g., "1234")
        },
        tos_acceptance: {
          date: Math.floor(Date.now() / 1000), // Current timestamp in seconds
          ip: req.ip || '127.0.0.1', // User's IP address (or fallback to localhost)
        },
      });
      console.log('Updated account with details:', updatedAccount);

      // Add an external bank account with Faker-generated details (using Stripe test bank details for consistency)
      const bankAccount = await stripe.accounts.createExternalAccount(account.id, {
        external_account: {
          object: 'bank_account',
          country: 'US',
          currency: 'usd',
          routing_number: '110000000', // Stripe test routing number
          account_number: faker.finance.accountNumber(12), // Random 12-digit account number (e.g., "000123456789")
        },
      });
      console.log('Added external account:', bankAccount);

      const verifyAccount = await stripe.accounts.retrieve(account.id);
      console.log('Verified account:', verifyAccount.id);
      console.log('Account status:', verifyAccount);

      dbUser.stripeConnectId = account.id;
      await dbUser.save();
      stripeConnectId = account.id;
    } else {
      const existingAccount = await stripe.accounts.retrieve(stripeConnectId);
      console.log('Existing account status:', existingAccount);
    }

    // Always generate a new account link
    const link = await stripe.accountLinks.create({
      account: stripeConnectId,
      refresh_url: `${process.env.FRONTEND_URL}/UOEPM04AddNewMethodCreator?onboarding=refresh`,
      return_url: `${process.env.FRONTEND_URL}/UOEPM04AddNewMethodCreator?onboarding=complete&connectId=${stripeConnectId}`,
      type: 'account_onboarding',
    });
    console.log('Account Link URL:', link.url);

    return res.json({ connectId: stripeConnectId, url: link.url });
  } catch (err) {
    console.error('onboardConnectAccount error:', err);
    return res.status(500).json({ error: err.message });
  }
};


exports.verifyConnectAccount = async (req, res) => {
  try {
    // User is attached by manualAuth middleware    
    const { connectId } = req.params;
    const { userId } = req.query;

    // Validate userId from query parameter
    if (!userId) {
      console.log('verifyConnectAccount: userId query parameter is missing');
      return res.status(400).json({ error: 'userId query parameter is required' });
    }
    if (!connectId) {
      return res.status(400).json({ error: 'Connect ID is required' });
    }

    // Retrieve the Stripe Connect account
    const account = await stripe.accounts.retrieve(connectId);
    console.log('Retrieved account:', account.id);
    console.log('Account metadata:', account.metadata);
    console.log('Account details_submitted:', account.details_submitted);
    console.log('Account requirements:', account.requirements);

    // Verify the account belongs to the user
    if (account.metadata.userId !== userId) {
      return res.status(403).json({ error: 'Unauthorized access to this Connect account' });
    }

    // Return the onboarding status
    return res.status(200).json({
      details_submitted: account.details_submitted,
    });
  } catch (err) {
    console.error('verifyConnectAccount error:', err);
    return res.status(500).json({ error: `Failed to verify Connect account: ${err.message}` });
  }
};